<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>Promise | Web Doc</title>
    <meta name="generator" content="VuePress 1.7.1">
    <link rel="icon" href="/web-doc/image/logo_dm_32.ico">
    <meta name="description" content="前端技术文档">
    <meta name="theme-color" content="#3eaf7c">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black">
    
    <link rel="preload" href="/web-doc/assets/css/0.styles.52e0cd3d.css" as="style"><link rel="preload" href="/web-doc/assets/js/app.968e2cce.js" as="script"><link rel="preload" href="/web-doc/assets/js/2.fa5e476e.js" as="script"><link rel="preload" href="/web-doc/assets/js/36.6320a278.js" as="script"><link rel="prefetch" href="/web-doc/assets/js/10.3c8c0460.js"><link rel="prefetch" href="/web-doc/assets/js/11.354ebf08.js"><link rel="prefetch" href="/web-doc/assets/js/12.d1978f9a.js"><link rel="prefetch" href="/web-doc/assets/js/13.6a005b4d.js"><link rel="prefetch" href="/web-doc/assets/js/14.8bd6c61b.js"><link rel="prefetch" href="/web-doc/assets/js/15.184d517b.js"><link rel="prefetch" href="/web-doc/assets/js/16.c75d1fa3.js"><link rel="prefetch" href="/web-doc/assets/js/17.ab3eac72.js"><link rel="prefetch" href="/web-doc/assets/js/18.600fbd9c.js"><link rel="prefetch" href="/web-doc/assets/js/19.2fd674d6.js"><link rel="prefetch" href="/web-doc/assets/js/20.e558302a.js"><link rel="prefetch" href="/web-doc/assets/js/21.4e2b4ec2.js"><link rel="prefetch" href="/web-doc/assets/js/22.d9e7cd0b.js"><link rel="prefetch" href="/web-doc/assets/js/23.b2773723.js"><link rel="prefetch" href="/web-doc/assets/js/24.a3a8f013.js"><link rel="prefetch" href="/web-doc/assets/js/25.e6ada6b1.js"><link rel="prefetch" href="/web-doc/assets/js/26.673b678d.js"><link rel="prefetch" href="/web-doc/assets/js/27.a7411a85.js"><link rel="prefetch" href="/web-doc/assets/js/28.1cb8b3f1.js"><link rel="prefetch" href="/web-doc/assets/js/29.b2012dec.js"><link rel="prefetch" href="/web-doc/assets/js/3.b67f60e8.js"><link rel="prefetch" href="/web-doc/assets/js/30.3698a203.js"><link rel="prefetch" href="/web-doc/assets/js/31.77072f1c.js"><link rel="prefetch" href="/web-doc/assets/js/32.cc30f380.js"><link rel="prefetch" href="/web-doc/assets/js/33.37018991.js"><link rel="prefetch" href="/web-doc/assets/js/34.97430545.js"><link rel="prefetch" href="/web-doc/assets/js/35.0955199c.js"><link rel="prefetch" href="/web-doc/assets/js/37.154e5c71.js"><link rel="prefetch" href="/web-doc/assets/js/38.805519c0.js"><link rel="prefetch" href="/web-doc/assets/js/39.00aa4147.js"><link rel="prefetch" href="/web-doc/assets/js/4.ed2fab8b.js"><link rel="prefetch" href="/web-doc/assets/js/40.af475e42.js"><link rel="prefetch" href="/web-doc/assets/js/41.28c0d991.js"><link rel="prefetch" href="/web-doc/assets/js/5.b6108d4b.js"><link rel="prefetch" href="/web-doc/assets/js/6.ab1ee22d.js"><link rel="prefetch" href="/web-doc/assets/js/7.921d680a.js"><link rel="prefetch" href="/web-doc/assets/js/8.906fb63f.js"><link rel="prefetch" href="/web-doc/assets/js/9.7147fa0d.js">
    <link rel="stylesheet" href="/web-doc/assets/css/0.styles.52e0cd3d.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/web-doc/" class="home-link router-link-active"><!----> <span class="site-name">Web Doc</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/web-doc/guide/" class="nav-link">
  管理后台
</a></div><div class="nav-item"><a href="/web-doc/new-member-guide/" class="nav-link">
  新手入门
</a></div><div class="nav-item"><a href="/web-doc/coding-style/" class="nav-link">
  风格指南
</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="工具" class="dropdown-title"><span class="title">工具</span> <span class="arrow down"></span></button> <button type="button" aria-label="工具" class="mobile-dropdown-title"><span class="title">工具</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/web-doc/tools/markdown/markdown.html" class="nav-link">
  Markdown
</a></li><li class="dropdown-item"><!----> <a href="/web-doc/promise/" aria-current="page" class="nav-link router-link-exact-active router-link-active">
  promise
</a></li><li class="dropdown-item"><!----> <a href="/web-doc/tools/hqchart/hqchart.html" class="nav-link">
  hqchart
</a></li></ul></div></div><div class="nav-item"><a href="/web-doc/reference/" class="nav-link">
  参考
</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="草稿" class="dropdown-title"><span class="title">草稿</span> <span class="arrow down"></span></button> <button type="button" aria-label="草稿" class="mobile-dropdown-title"><span class="title">草稿</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/web-doc/draft/gcf.html" class="nav-link">
  gcf
</a></li><li class="dropdown-item"><!----> <a href="/web-doc/draft/dgz.html" class="nav-link">
  dgz
</a></li><li class="dropdown-item"><!----> <a href="/web-doc/draft/zs.html" class="nav-link">
  zs
</a></li></ul></div></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/web-doc/guide/" class="nav-link">
  管理后台
</a></div><div class="nav-item"><a href="/web-doc/new-member-guide/" class="nav-link">
  新手入门
</a></div><div class="nav-item"><a href="/web-doc/coding-style/" class="nav-link">
  风格指南
</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="工具" class="dropdown-title"><span class="title">工具</span> <span class="arrow down"></span></button> <button type="button" aria-label="工具" class="mobile-dropdown-title"><span class="title">工具</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/web-doc/tools/markdown/markdown.html" class="nav-link">
  Markdown
</a></li><li class="dropdown-item"><!----> <a href="/web-doc/promise/" aria-current="page" class="nav-link router-link-exact-active router-link-active">
  promise
</a></li><li class="dropdown-item"><!----> <a href="/web-doc/tools/hqchart/hqchart.html" class="nav-link">
  hqchart
</a></li></ul></div></div><div class="nav-item"><a href="/web-doc/reference/" class="nav-link">
  参考
</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="草稿" class="dropdown-title"><span class="title">草稿</span> <span class="arrow down"></span></button> <button type="button" aria-label="草稿" class="mobile-dropdown-title"><span class="title">草稿</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/web-doc/draft/gcf.html" class="nav-link">
  gcf
</a></li><li class="dropdown-item"><!----> <a href="/web-doc/draft/dgz.html" class="nav-link">
  dgz
</a></li><li class="dropdown-item"><!----> <a href="/web-doc/draft/zs.html" class="nav-link">
  zs
</a></li></ul></div></div> <!----></nav>  <ul class="sidebar-links"><li><section class="sidebar-group depth-0"><p class="sidebar-heading open"><span>Promise</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/web-doc/promise/#回调函数和回调地狱" class="sidebar-link">回调函数和回调地狱</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/web-doc/promise/#回调函数-callback" class="sidebar-link">回调函数（Callback）</a></li><li class="sidebar-sub-header"><a href="/web-doc/promise/#回调地狱-callback-hell" class="sidebar-link">回调地狱（Callback hell）</a></li></ul></li><li><a href="/web-doc/promise/#promise-then、catch、all、reject、resolve" class="sidebar-link">Promise(then、catch、all、reject、resolve)</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/web-doc/promise/#promise-all-批量执行" class="sidebar-link">Promise.all() 批量执行</a></li><li class="sidebar-sub-header"><a href="/web-doc/promise/#promise-race-的使用" class="sidebar-link">Promise.race()的使用</a></li></ul></li></ul></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="promise"><a href="#promise" class="header-anchor">#</a> Promise</h1> <h2 id="回调函数和回调地狱"><a href="#回调函数和回调地狱" class="header-anchor">#</a> 回调函数和回调地狱</h2> <ul><li>要想理解Promise是干什么的，首先先了解一下什么是回调函数，回调地狱吧</li></ul> <h3 id="回调函数-callback"><a href="#回调函数-callback" class="header-anchor">#</a> 回调函数（Callback）</h3> <p>回调函数就是一个参数，将这个函数作为参数传到另一个函数里面，当这个函数执行完之后，再去执行传进去这个函数，这个过程叫回调。<br>
　　举一个别人举过的例子：约会结束后你送你女朋友回家，离别时，你肯定会说：“到家了给我发条信息，我很担心你。” 对不，然后你女朋友回家以后还真给你发了条信息。小伙子，你有戏了。其实这就是一个回调的过程。你留了个参数函数（要求女朋友给你发条信息）给你女朋友，然后你女朋友回家，回家的动作是主函数。她必须先回到家以后，主函数执行完了，再执行传进去的函数，然后你就收到一条信息了。</p> <div class="language- extra-class"><pre class="language-text"><code>//定义主函数，回调函数作为参数
function A(callback) {
    callback();  
    console.log('我是主函数');      
}
 
//定义回调函数
function B(){
    setTimeout(&quot;console.log('我是回调函数')&quot;, 3000);//模仿耗时操作  
}
 
//调用主函数，将函数B传进去
A(B);
 
//输出结果
我是主函数
我是回调函数
</code></pre></div><p>上面的代码中，我们先定义了主函数和回调函数，然后再去调用主函数，将回调函数传进去。</p> <p>定义主函数的时候，我们让代码先去执行callback()回调函数，但输出结果却是后输出回调函数的内容。这就说明了主函数不用等待回调函数执行完，可以接着执行自己的代码。所以一般回调函数都用在耗时操作上面。比如ajax请求，比如处理文件等。</p> <h3 id="回调地狱-callback-hell"><a href="#回调地狱-callback-hell" class="header-anchor">#</a> 回调地狱（Callback hell）</h3> <p>什么是回调地狱，回调函数，一个嵌套着一个，到最后，缩略图成了一个三角形造成了可阅读性差，可阅读性差就代表代码的可维护性 和 可迭代性差，最后还有一个就是可扩展性差。
也不符合设计模式的六大原则，其中的单一职责原则和开闭原则<br>
单一职责原则：尽量让一个函数只做一件事情<br>
开闭原则：函数应该对扩展开放,对修改关闭<br>
在没有学会promise之前，当我遇到连续使用多个ajax请求的情况，并且做ajax请求时，这个新的ajax请求的其中一个参数，得从上一个ajax请求中获取时，就需要回调函数套回调函数了，就很可能出现回调地狱的情况</p> <p>场景一  ：关于ajax发请求的问题</p> <div class="language- extra-class"><pre class="language-text"><code>//假设我已经引用了jQuery
$(&quot;button&quot;).click(function(){
  $.get(&quot;demo_test.asp&quot;,function(result){
  	console.log(&quot;假装这里有一些代码&quot;);
  	//这里就需要拿到这次ajax请求返回的数据，拼接成新的url，用于再次发起第二个ajax请求，所以第二个请求要写在第一个请求的callback中
	var url = &quot;demo_test.asp?name:&quot;+result;	
	$.get(url,function(result2){
       	  console.log(&quot;假装这里又有一些代码&quot;);
		/*
   		  如果我还要发第三个请求，而且第三个请求需要用到第二个请求返回的数据，
   		  那么又需要将第三个请求写在第二个请求的callback中的,我们再极端的想想，
   		  如果这样的情况要重复10次，20次，那样就会有10个，20个回调函数套回调
   		  函数这样就会出现回调地狱了。然鹅，Promise很好的解决了这个问题。
 		*/
  	});
  });
});
</code></pre></div><ul><li>主角终于要出场了，看看Promise如何解决这种情况</li></ul> <div class="language- extra-class"><pre class="language-text"><code>//假设我已经引用了jQuery
function test(){
	$.get(&quot;demo_test.asp&quot;,function(result){
  		console.log(&quot;假装这里有一些代码&quot;);
  	  	// 返回Promise对象
  	  	return new Promise(function(resolve) {  //这里还可以传入第二个参数reject(可选)
  	  		resolve(result);
  	 	 });
 	});
};
$(&quot;button&quot;).click(()=&gt;{
	test()
	.then((result)=&gt;{
		var url = &quot;demo_test.asp?name:&quot;+result;	
		return url；//返回一个Promise对象，带有参数url，可以直接在下一个then中使用
	})
	.then((url)=&gt;{
		$.get(url,function(result2){
		console.log(&quot;假装这里又有一些代码&quot;);
       	  	return result2;  //这里又可以把请求的结果返回出来，接着用then做下一个请求
        });
	})
	.then((result2)=&gt;{
		//巴拉巴拉又是一堆代码
	})
});
</code></pre></div><p>场景二：取4个定时器，设置延迟时间都为1s，然后每隔1s依次在控制台输出‘我’‘爱’‘米’‘饭’的字样。代码如下：</p> <div class="language- extra-class"><pre class="language-text"><code>setTimeout(function () {
          console.log('我');
          setTimeout(function () {
              console.log('爱');
              setTimeout(function () {
                  console.log('米');
                  setTimeout(function () {
                      console.log('饭');
                  }, 1000);
              }, 1000);
          }, 1000);
      }, 1000);
</code></pre></div><p>发现什么问题没有？是不是有点感觉回调函数的嵌套有点多，如果有更多的回调函数呢？是不是使代码的可读性和可维护性都大大降低了呢（回调地狱？），这时如果我们使用Promise去实现这个效果，虽然可能代码不会减少，甚至更多，但是却大大增强了其可读性和可维护性。具体看下面例子：</p> <div class="language- extra-class"><pre class="language-text"><code>function getStr1() {
    return new Promise(function (resolve, reject) {
        setTimeout(function () {
            resolve('我');
        }, 1000);
    });
}
function getStr2() {
    return new Promise(function (resolve, reject) {
        setTimeout(function () {
            resolve('爱');
        }, 1000);
    });
}
function getStr3() {
    return new Promise(function (resolve, reject) {
        setTimeout(function () {
            resolve('米');
        }, 1000);
    });
}
function getStr4() {
    return new Promise(function (resolve, reject) {
        setTimeout(function () {
            resolve('饭');
        }, 1000);
    });
}
getStr1().then(function (data) {
    console.log(data);
    return getStr2();
}).then(function (data) {
    console.log(data);
    return getStr3();
}).then(function (data) {
    console.log(data);
    return getStr4();
}).then(function (data) {
    console.log(data);
})
</code></pre></div><p>执行效果跟上面一样，在这个例子中，将得到Promise实例的过程封装成一个函数（getStr1，getStr2,getStr3,getStr4）并返回一个Promise实例，再用实例去调用相应的then方法，在每个then方法中通过return得到下一级的Promise实例，比如在第一个Promise实例（getStr1（））then方法中，通过return返回下一个Promise对象（getStr2（）），然后再去调用then方法执行里面的操作，再返回下一个Promise对象（这里是getStr3()），
两种方式运行结果如下：<br> <img src="/web-doc/image/5.png" alt="运行结果"></p> <h2 id="promise-then、catch、all、reject、resolve"><a href="#promise-then、catch、all、reject、resolve" class="header-anchor">#</a> Promise(then、catch、all、reject、resolve)</h2> <ul><li>好啦，我想刚入门的小白现在对Promise应该还是不是太了解，没关系现在正式的介绍一下吧<br> <strong>Promise 是异步编程的一种解决方案，其实是一个构造函数，自己身上有all、reject、resolve这几个方法，原型上有then、catch等方法。</strong></li></ul> <p><strong>基本概念</strong></p> <ol><li>Promise是一个构造函数，所以可以 new 出一个Promise的实例</li> <li>在Promise上有两个函数 resolve(成功之后的回调函数)和 reject(失败后的回调函数)</li> <li>在Promise构造函数的prototype属性上，有一个 .then() 方法。所以只要是Promise构造函数创建的实例，都可以访问到 .then()方法</li> <li>Promise表示一个一步操作，每当我们new一个Promise的实例，这个实例就代表具体的异步操作。</li> <li>Promise创建的实例，是一个异步操作，这个异步操作结果，只有两种结果
<ul><li>状态1：异步执行成功，需要在内部调用成功的回调函数resolve把结果返   回给调用者</li> <li>状态2：异步执行失败，需要在内部调用失败的回调函数reject把结果返回调用者</li></ul></li> <li>由于Promise的实例是一个异步操作，所以内部拿到操作结果后，无法使用return把操作结果返回给调用者，这个时候只能使用回调函数的形式，把成功或失败的结果，返回给调用者</li></ol> <p>实际应用场景:<br>
比如我们在注册页面的时候,就用到了Promise对象,我们第一步发送请求去验证用户名是否已经注册,验证完用户名没有被注册后再进行第二步验证手机动态码,手机动态验证码正确了,然后再进行第三步把注册的信息写入数据库当中.<br>
Promise，简单说就是一个容器，里面保存着某个未来才会结束的事件（通常是一个异步操作）的结果。从语法上说，Promise 是一个对象，从它可以获取异步操作的消息。</p> <p>Promise 提供统一的 API，各种异步操作都可以用同样的方法进行处理。</p> <p>Promise对象有以下两个特点：</p> <p>（1）对象的状态不受外界影响。Promise对象代表一个异步操作，有三种状态：Pending（进行中）、Resolved（已完成，又称 Fulfilled）和Rejected（已失败）。只有异步操作的结果，可以决定当前是哪一种状态，任何其他操作都无法改变这个状态。这也是Promise这个名字的由来，它的英语意思就是“承诺”，表示其他手段无法改变。</p> <p>（2）一旦状态改变，就不会再变，任何时候都可以得到这个结果。Promise对象的状态改变，只有两种可能：从Pending变为Resolved和从Pending变为Rejected。只要这两种情况发生，状态就凝固了，不会再变了，会一直保持这个结果。就算改变已经发生了，你再对Promise对象添加回调函数，也会立即得到这个结果。这与事件（Event）完全不同，事件的特点是，如果你错过了它，再去监听，是得不到结果的。</p> <p>有了Promise对象，就可以将异步操作以同步操作的流程表达出来，避免了层层嵌套的回调函数。此外，Promise对象提供统一的接口，使得控制异步操作更加容易。</p> <p><strong>简单来说，Promise 就是用同步的方式写异步的代码，用来解决回调问题</strong></p> <p>先看一下下面4个Promise到底有什么区别呢？(如果您知道答案以下内容你可以不用继续）</p> <div class="language- extra-class"><pre class="language-text"><code>func().then(function () {
  return cb();
});
 
func().then(function () {
  cb();
});
 
func().then(cb());
 
func().then(cb);
</code></pre></div><p>请往下看</p> <div class="language- extra-class"><pre class="language-text"><code>let func = function() {
    return new Promise((resolve, reject) =&gt; {
        resolve('返回值');
    });
};

let cb = function() {
    return '新的值';
}

func().then(function () {
    return cb();
}).then(resp =&gt; {
    console.warn(resp);
    console.warn('1 =========&lt;');
});

func().then(function () {
    cb();
}).then(resp =&gt; {
    console.warn(resp);
    console.warn('2 =========&lt;');
});

func().then(cb()).then(resp =&gt; {
    console.warn(resp);
    console.warn('3 =========&lt;');
});

func().then(cb).then(resp =&gt; {
    console.warn(resp);
    console.warn('4 =========&lt;');
});
</code></pre></div><p>直接看结果<br> <img src="/web-doc/image/1.png" alt="运行结果"><br>
是不是有些迷惑，感觉长的都一样啊，为什么结果会不同，那么then都干了什么事情呢</p> <p><strong>官方文档是这样定义的</strong></p> <div class="language- extra-class"><pre class="language-text"><code>一个 promise 必须提供一个 then 方法以访问其当前值、终值和据因。
promise 的 then 方法接受两个参数：

promise.then(onFulfilled, onRejected) Todo:这里只介绍onFulfilled，所以删除了关于onRejected的规范定义

onFulfilled 和 onRejected 都是可选参数。

如果 onFulfilled 不是函数，其必须被忽略
如果 onFulfilled 是函数：

当 promise 执行结束后其必须被调用，其第一个参数为 promise 的终值
在 promise 执行结束前其不可被调用
其调用次数不可超过一次
</code></pre></div><p>官方大大说的总是那么官方，但是我们理解起来就......en,可以这样理解</p> <p>then方法提供一个供自定义的回调函数，若传入非函数，则会忽略当前then方法。
回调函数中会把上一个then中返回的值当做参数值供当前then方法调用。
then方法执行完毕后需要返回一个新的值给下一个then调用（没有返回值默认使用undefined）。
每个then只可能使用前一个then的返回值。<br> <img src="/web-doc/image/2.png" alt="直观的图"><br>
哇!我觉得这张图这是太棒了!!!看到这里对then是不是感觉明白了很多呢,如果还是不明白我们看一下对上面的例子的分析<br>
分析解释：</p> <p>执行第一个方法：</p> <div class="language- extra-class"><pre class="language-text"><code>
func().then(function () {
    return cb();
}).then(resp =&gt; {
    console.warn(resp);
    console.warn('1 =========&lt;');
});
 
返回结果：  新的值
                
           1   =========&lt;
因为传入了回调函数，而且回调函数中把cb执行后的返回值当做then中的返回值，所以输出了&quot;新的值
</code></pre></div><p>执行第二个方法：</p> <div class="language- extra-class"><pre class="language-text"><code>func().then(function () {
    cb();
}).then(resp =&gt; {
    console.warn(resp);
    console.warn('2 =========&lt;');
});
 
返回结果：  undefined
                
           2   =========&lt;
因为虽然传入了回调方法，只是执行了cb方法，并没有return值，定义中讲过若没有返回值，提供下一个then使用的参数就是undefined，所以打印出来就是undefined
</code></pre></div><p>执行第三个方法：</p> <div class="language- extra-class"><pre class="language-text"><code>
func().then(cb()).then(resp =&gt; {
    console.warn(resp);
    console.warn('3 =========&lt;');
});
 
返回结果：  返回值
                
           3   =========&lt;
因为then中cb()执行后返回的并不是一个函数，在Promise规范中会自动忽略调当前then，所以会把func中的返回值供下一个then使用，输出了“返回值”
</code></pre></div><p>执行第四个方法：</p> <div class="language- extra-class"><pre class="language-text"><code>func().then(cb).then(resp =&gt; {
    console.warn(resp);
    console.warn('4 =========&lt;');
});
 
返回结果：  新的值
                
           4   =========&lt;
因为第一个方法在回调内部返回cb执行后的值，第四个方法则直接把cb当做回调，第一个方法与第四个方法异曲同工之妙，所以也输出了“新的值”。
</code></pre></div><p><a href="https://promisesaplus.com/" target="_blank" rel="noopener noreferrer">Promise规范（https://promisesaplus.com/）<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <p>好啦，then说到这里说的已经够多了，现在我们来了解另一个朋友<strong>catch</strong>吧</p> <p>与Promise对象方法then方法并行的一个方法就是catch,与try  catch类似，catch就是用来捕获异常的，也就是和then方法中接受的第二参数rejected的回调是一样的，如下：</p> <div class="language- extra-class"><pre class="language-text"><code>function promiseClick(){
		let p = new Promise(function(resolve, reject){
			setTimeout(function(){
				var num = Math.ceil(Math.random()*20); //生成1-10的随机数
				console.log('随机数生成的值：',num)
				if(num&lt;=10){
					resolve(num);
				}
				else{
					reject('数字大于10了即将执行失败回调');
				}
			}, 2000);
		   })
		   return p
	   }
 
	promiseClick().then(
		function(data){
			console.log('resolved成功回调');
			console.log('成功回调接受的值：',data);
		}
	)
	.catch(function(reason){
		console.log('catch到rejected失败回调');
		console.log('失败回调的值：',reason);
	});	
</code></pre></div><p>输出结果：</p> <img src="/web-doc/image/4.png" alt="直观的图"> <img src="/web-doc/image/3.png" alt="直观的图"> <p>resolve的东西，一定会进入then的第一个回调，肯定不会进入catch<br>
reject后的东西，一定会进入then中的第二个回调，如果then中没有写第二个回调，则进入catch，
<strong>另外，网络异常（比如断网），会直接进入catch而不会进入then的第二个回调</strong></p> <h3 id="promise-all-批量执行"><a href="#promise-all-批量执行" class="header-anchor">#</a> Promise.all() 批量执行</h3> <p>Promise.all可以将多个Promise实例包装成一个新的Promise实例。同时，成功和失败的返回值是不同的，成功的时候返回的是一个结果数组，而失败的时候则返回最先被reject失败状态的值。 Promse.all在处理多个异步处理时非常有用，比如说一个页面上需要等两个或多个ajax的数据回来以后才正常显示，在此之前只显示loading图标。</p> <div class="language- extra-class"><pre class="language-text"><code>let wake = (time) =&gt; {
  return new Promise((resolve, reject) =&gt; {
    setTimeout(() =&gt; {
      resolve(`${time / 1000}秒后醒来`)
    }, time)
  })
}

let p1 = wake(3000)
let p2 = wake(2000)

Promise.all([p1, p2]).then((result) =&gt; {
  console.log(result)       // [ '3秒后醒来', '2秒后醒来' ]
}).catch((error) =&gt; {
  console.log(error)
})

</code></pre></div><p><strong>需要特别注意的是，Promise.all获得的成功结果的数组里面的数据顺序和Promise.all接收到的数组顺序是一致的，即p1的结果在前，即便p1的结果获取的比p2要晚。这带来了一个绝大的好处：在前端开发请求数据的过程中，偶尔会遇到发送多个请求并根据请求顺序获取和使用数据的场景，使用Promise.all毫无疑问可以解决这个问题。</strong></p> <h3 id="promise-race-的使用"><a href="#promise-race-的使用" class="header-anchor">#</a> Promise.race()的使用</h3> <p>顾名思义，Promse.race就是赛跑的意思，意思就是说，Promise.race([p1, p2, p3])里面哪个结果获得的快，就返回那个结果，不管结果本身是成功状态还是失败状态。</p> <div class="language- extra-class"><pre class="language-text"><code>let p1 = new Promise((resolve, reject) =&gt; {
  setTimeout(() =&gt; {
    resolve('success')
  },1000)
})

let p2 = new Promise((resolve, reject) =&gt; {
  setTimeout(() =&gt; {
    reject('failed')
  }, 500)
})

Promise.race([p1, p2]).then((result) =&gt; {
  console.log(result)
}).catch((error) =&gt; {
  console.log(error)  // 打开的是 'failed'
})
</code></pre></div><p><strong>总而言之，言而总之，我觉得大多数人喜欢promise很大的原因呢就是因为他长的好看，又瘦又高，还有就因为他的家族庞大，有reject,resolve,all，then,catch...</strong></p></div> <footer class="page-edit"><!----> <!----></footer> <!----> </main></div><div class="global-ui"><!----></div></div>
    <script src="/web-doc/assets/js/app.968e2cce.js" defer></script><script src="/web-doc/assets/js/2.fa5e476e.js" defer></script><script src="/web-doc/assets/js/36.6320a278.js" defer></script>
  </body>
</html>
