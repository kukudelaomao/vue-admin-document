(window.webpackJsonp=window.webpackJsonp||[]).push([[36],{408:function(e,n,t){"use strict";t.r(n);var r=t(25),s=Object(r.a)({},(function(){var e=this,n=e.$createElement,t=e._self._c||n;return t("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[t("h1",{attrs:{id:"promise"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#promise"}},[e._v("#")]),e._v(" Promise")]),e._v(" "),t("h2",{attrs:{id:"回调函数和回调地狱"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#回调函数和回调地狱"}},[e._v("#")]),e._v(" 回调函数和回调地狱")]),e._v(" "),t("ul",[t("li",[e._v("要想理解Promise是干什么的，首先先了解一下什么是回调函数，回调地狱吧")])]),e._v(" "),t("h3",{attrs:{id:"回调函数-callback"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#回调函数-callback"}},[e._v("#")]),e._v(" 回调函数（Callback）")]),e._v(" "),t("p",[e._v("回调函数就是一个参数，将这个函数作为参数传到另一个函数里面，当这个函数执行完之后，再去执行传进去这个函数，这个过程叫回调。"),t("br"),e._v("\n　　举一个别人举过的例子：约会结束后你送你女朋友回家，离别时，你肯定会说：“到家了给我发条信息，我很担心你。” 对不，然后你女朋友回家以后还真给你发了条信息。小伙子，你有戏了。其实这就是一个回调的过程。你留了个参数函数（要求女朋友给你发条信息）给你女朋友，然后你女朋友回家，回家的动作是主函数。她必须先回到家以后，主函数执行完了，再执行传进去的函数，然后你就收到一条信息了。")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("//定义主函数，回调函数作为参数\nfunction A(callback) {\n    callback();  \n    console.log('我是主函数');      \n}\n \n//定义回调函数\nfunction B(){\n    setTimeout(\"console.log('我是回调函数')\", 3000);//模仿耗时操作  \n}\n \n//调用主函数，将函数B传进去\nA(B);\n \n//输出结果\n我是主函数\n我是回调函数\n")])])]),t("p",[e._v("上面的代码中，我们先定义了主函数和回调函数，然后再去调用主函数，将回调函数传进去。")]),e._v(" "),t("p",[e._v("定义主函数的时候，我们让代码先去执行callback()回调函数，但输出结果却是后输出回调函数的内容。这就说明了主函数不用等待回调函数执行完，可以接着执行自己的代码。所以一般回调函数都用在耗时操作上面。比如ajax请求，比如处理文件等。")]),e._v(" "),t("h3",{attrs:{id:"回调地狱-callback-hell"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#回调地狱-callback-hell"}},[e._v("#")]),e._v(" 回调地狱（Callback hell）")]),e._v(" "),t("p",[e._v("什么是回调地狱，回调函数，一个嵌套着一个，到最后，缩略图成了一个三角形造成了可阅读性差，可阅读性差就代表代码的可维护性 和 可迭代性差，最后还有一个就是可扩展性差。\n也不符合设计模式的六大原则，其中的单一职责原则和开闭原则"),t("br"),e._v("\n单一职责原则：尽量让一个函数只做一件事情"),t("br"),e._v("\n开闭原则：函数应该对扩展开放,对修改关闭"),t("br"),e._v("\n在没有学会promise之前，当我遇到连续使用多个ajax请求的情况，并且做ajax请求时，这个新的ajax请求的其中一个参数，得从上一个ajax请求中获取时，就需要回调函数套回调函数了，就很可能出现回调地狱的情况")]),e._v(" "),t("p",[e._v("场景一  ：关于ajax发请求的问题")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v('//假设我已经引用了jQuery\n$("button").click(function(){\n  $.get("demo_test.asp",function(result){\n  \tconsole.log("假装这里有一些代码");\n  \t//这里就需要拿到这次ajax请求返回的数据，拼接成新的url，用于再次发起第二个ajax请求，所以第二个请求要写在第一个请求的callback中\n\tvar url = "demo_test.asp?name:"+result;\t\n\t$.get(url,function(result2){\n       \t  console.log("假装这里又有一些代码");\n\t\t/*\n   \t\t  如果我还要发第三个请求，而且第三个请求需要用到第二个请求返回的数据，\n   \t\t  那么又需要将第三个请求写在第二个请求的callback中的,我们再极端的想想，\n   \t\t  如果这样的情况要重复10次，20次，那样就会有10个，20个回调函数套回调\n   \t\t  函数这样就会出现回调地狱了。然鹅，Promise很好的解决了这个问题。\n \t\t*/\n  \t});\n  });\n});\n')])])]),t("ul",[t("li",[e._v("主角终于要出场了，看看Promise如何解决这种情况")])]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v('//假设我已经引用了jQuery\nfunction test(){\n\t$.get("demo_test.asp",function(result){\n  \t\tconsole.log("假装这里有一些代码");\n  \t  \t// 返回Promise对象\n  \t  \treturn new Promise(function(resolve) {  //这里还可以传入第二个参数reject(可选)\n  \t  \t\tresolve(result);\n  \t \t });\n \t});\n};\n$("button").click(()=>{\n\ttest()\n\t.then((result)=>{\n\t\tvar url = "demo_test.asp?name:"+result;\t\n\t\treturn url；//返回一个Promise对象，带有参数url，可以直接在下一个then中使用\n\t})\n\t.then((url)=>{\n\t\t$.get(url,function(result2){\n\t\tconsole.log("假装这里又有一些代码");\n       \t  \treturn result2;  //这里又可以把请求的结果返回出来，接着用then做下一个请求\n        });\n\t})\n\t.then((result2)=>{\n\t\t//巴拉巴拉又是一堆代码\n\t})\n});\n')])])]),t("p",[e._v("场景二：取4个定时器，设置延迟时间都为1s，然后每隔1s依次在控制台输出‘我’‘爱’‘米’‘饭’的字样。代码如下：")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("setTimeout(function () {\n          console.log('我');\n          setTimeout(function () {\n              console.log('爱');\n              setTimeout(function () {\n                  console.log('米');\n                  setTimeout(function () {\n                      console.log('饭');\n                  }, 1000);\n              }, 1000);\n          }, 1000);\n      }, 1000);\n")])])]),t("p",[e._v("发现什么问题没有？是不是有点感觉回调函数的嵌套有点多，如果有更多的回调函数呢？是不是使代码的可读性和可维护性都大大降低了呢（回调地狱？），这时如果我们使用Promise去实现这个效果，虽然可能代码不会减少，甚至更多，但是却大大增强了其可读性和可维护性。具体看下面例子：")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("function getStr1() {\n    return new Promise(function (resolve, reject) {\n        setTimeout(function () {\n            resolve('我');\n        }, 1000);\n    });\n}\nfunction getStr2() {\n    return new Promise(function (resolve, reject) {\n        setTimeout(function () {\n            resolve('爱');\n        }, 1000);\n    });\n}\nfunction getStr3() {\n    return new Promise(function (resolve, reject) {\n        setTimeout(function () {\n            resolve('米');\n        }, 1000);\n    });\n}\nfunction getStr4() {\n    return new Promise(function (resolve, reject) {\n        setTimeout(function () {\n            resolve('饭');\n        }, 1000);\n    });\n}\ngetStr1().then(function (data) {\n    console.log(data);\n    return getStr2();\n}).then(function (data) {\n    console.log(data);\n    return getStr3();\n}).then(function (data) {\n    console.log(data);\n    return getStr4();\n}).then(function (data) {\n    console.log(data);\n})\n")])])]),t("p",[e._v("执行效果跟上面一样，在这个例子中，将得到Promise实例的过程封装成一个函数（getStr1，getStr2,getStr3,getStr4）并返回一个Promise实例，再用实例去调用相应的then方法，在每个then方法中通过return得到下一级的Promise实例，比如在第一个Promise实例（getStr1（））then方法中，通过return返回下一个Promise对象（getStr2（）），然后再去调用then方法执行里面的操作，再返回下一个Promise对象（这里是getStr3()），\n两种方式运行结果如下："),t("br"),e._v(" "),t("img",{attrs:{src:e.$withBase("/image/5.png"),alt:"运行结果"}})]),e._v(" "),t("h2",{attrs:{id:"promise-then、catch、all、reject、resolve"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#promise-then、catch、all、reject、resolve"}},[e._v("#")]),e._v(" Promise(then、catch、all、reject、resolve)")]),e._v(" "),t("ul",[t("li",[e._v("好啦，我想刚入门的小白现在对Promise应该还是不是太了解，没关系现在正式的介绍一下吧"),t("br"),e._v(" "),t("strong",[e._v("Promise 是异步编程的一种解决方案，其实是一个构造函数，自己身上有all、reject、resolve这几个方法，原型上有then、catch等方法。")])])]),e._v(" "),t("p",[t("strong",[e._v("基本概念")])]),e._v(" "),t("ol",[t("li",[e._v("Promise是一个构造函数，所以可以 new 出一个Promise的实例")]),e._v(" "),t("li",[e._v("在Promise上有两个函数 resolve(成功之后的回调函数)和 reject(失败后的回调函数)")]),e._v(" "),t("li",[e._v("在Promise构造函数的prototype属性上，有一个 .then() 方法。所以只要是Promise构造函数创建的实例，都可以访问到 .then()方法")]),e._v(" "),t("li",[e._v("Promise表示一个一步操作，每当我们new一个Promise的实例，这个实例就代表具体的异步操作。")]),e._v(" "),t("li",[e._v("Promise创建的实例，是一个异步操作，这个异步操作结果，只有两种结果\n"),t("ul",[t("li",[e._v("状态1：异步执行成功，需要在内部调用成功的回调函数resolve把结果返   回给调用者")]),e._v(" "),t("li",[e._v("状态2：异步执行失败，需要在内部调用失败的回调函数reject把结果返回调用者")])])]),e._v(" "),t("li",[e._v("由于Promise的实例是一个异步操作，所以内部拿到操作结果后，无法使用return把操作结果返回给调用者，这个时候只能使用回调函数的形式，把成功或失败的结果，返回给调用者")])]),e._v(" "),t("p",[e._v("实际应用场景:"),t("br"),e._v("\n比如我们在注册页面的时候,就用到了Promise对象,我们第一步发送请求去验证用户名是否已经注册,验证完用户名没有被注册后再进行第二步验证手机动态码,手机动态验证码正确了,然后再进行第三步把注册的信息写入数据库当中."),t("br"),e._v("\nPromise，简单说就是一个容器，里面保存着某个未来才会结束的事件（通常是一个异步操作）的结果。从语法上说，Promise 是一个对象，从它可以获取异步操作的消息。")]),e._v(" "),t("p",[e._v("Promise 提供统一的 API，各种异步操作都可以用同样的方法进行处理。")]),e._v(" "),t("p",[e._v("Promise对象有以下两个特点：")]),e._v(" "),t("p",[e._v("（1）对象的状态不受外界影响。Promise对象代表一个异步操作，有三种状态：Pending（进行中）、Resolved（已完成，又称 Fulfilled）和Rejected（已失败）。只有异步操作的结果，可以决定当前是哪一种状态，任何其他操作都无法改变这个状态。这也是Promise这个名字的由来，它的英语意思就是“承诺”，表示其他手段无法改变。")]),e._v(" "),t("p",[e._v("（2）一旦状态改变，就不会再变，任何时候都可以得到这个结果。Promise对象的状态改变，只有两种可能：从Pending变为Resolved和从Pending变为Rejected。只要这两种情况发生，状态就凝固了，不会再变了，会一直保持这个结果。就算改变已经发生了，你再对Promise对象添加回调函数，也会立即得到这个结果。这与事件（Event）完全不同，事件的特点是，如果你错过了它，再去监听，是得不到结果的。")]),e._v(" "),t("p",[e._v("有了Promise对象，就可以将异步操作以同步操作的流程表达出来，避免了层层嵌套的回调函数。此外，Promise对象提供统一的接口，使得控制异步操作更加容易。")]),e._v(" "),t("p",[t("strong",[e._v("简单来说，Promise 就是用同步的方式写异步的代码，用来解决回调问题")])]),e._v(" "),t("p",[e._v("先看一下下面4个Promise到底有什么区别呢？(如果您知道答案以下内容你可以不用继续）")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("func().then(function () {\n  return cb();\n});\n \nfunc().then(function () {\n  cb();\n});\n \nfunc().then(cb());\n \nfunc().then(cb);\n")])])]),t("p",[e._v("请往下看")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("let func = function() {\n    return new Promise((resolve, reject) => {\n        resolve('返回值');\n    });\n};\n\nlet cb = function() {\n    return '新的值';\n}\n\nfunc().then(function () {\n    return cb();\n}).then(resp => {\n    console.warn(resp);\n    console.warn('1 =========<');\n});\n\nfunc().then(function () {\n    cb();\n}).then(resp => {\n    console.warn(resp);\n    console.warn('2 =========<');\n});\n\nfunc().then(cb()).then(resp => {\n    console.warn(resp);\n    console.warn('3 =========<');\n});\n\nfunc().then(cb).then(resp => {\n    console.warn(resp);\n    console.warn('4 =========<');\n});\n")])])]),t("p",[e._v("直接看结果"),t("br"),e._v(" "),t("img",{attrs:{src:e.$withBase("/image/1.png"),alt:"运行结果"}}),t("br"),e._v("\n是不是有些迷惑，感觉长的都一样啊，为什么结果会不同，那么then都干了什么事情呢")]),e._v(" "),t("p",[t("strong",[e._v("官方文档是这样定义的")])]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("一个 promise 必须提供一个 then 方法以访问其当前值、终值和据因。\npromise 的 then 方法接受两个参数：\n\npromise.then(onFulfilled, onRejected) Todo:这里只介绍onFulfilled，所以删除了关于onRejected的规范定义\n\nonFulfilled 和 onRejected 都是可选参数。\n\n如果 onFulfilled 不是函数，其必须被忽略\n如果 onFulfilled 是函数：\n\n当 promise 执行结束后其必须被调用，其第一个参数为 promise 的终值\n在 promise 执行结束前其不可被调用\n其调用次数不可超过一次\n")])])]),t("p",[e._v("官方大大说的总是那么官方，但是我们理解起来就......en,可以这样理解")]),e._v(" "),t("p",[e._v("then方法提供一个供自定义的回调函数，若传入非函数，则会忽略当前then方法。\n回调函数中会把上一个then中返回的值当做参数值供当前then方法调用。\nthen方法执行完毕后需要返回一个新的值给下一个then调用（没有返回值默认使用undefined）。\n每个then只可能使用前一个then的返回值。"),t("br"),e._v(" "),t("img",{attrs:{src:e.$withBase("/image/2.png"),alt:"直观的图"}}),t("br"),e._v("\n哇!我觉得这张图这是太棒了!!!看到这里对then是不是感觉明白了很多呢,如果还是不明白我们看一下对上面的例子的分析"),t("br"),e._v("\n分析解释：")]),e._v(" "),t("p",[e._v("执行第一个方法：")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("\nfunc().then(function () {\n    return cb();\n}).then(resp => {\n    console.warn(resp);\n    console.warn('1 =========<');\n});\n \n返回结果：  新的值\n                \n           1   =========<\n因为传入了回调函数，而且回调函数中把cb执行后的返回值当做then中的返回值，所以输出了\"新的值\n")])])]),t("p",[e._v("执行第二个方法：")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("func().then(function () {\n    cb();\n}).then(resp => {\n    console.warn(resp);\n    console.warn('2 =========<');\n});\n \n返回结果：  undefined\n                \n           2   =========<\n因为虽然传入了回调方法，只是执行了cb方法，并没有return值，定义中讲过若没有返回值，提供下一个then使用的参数就是undefined，所以打印出来就是undefined\n")])])]),t("p",[e._v("执行第三个方法：")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("\nfunc().then(cb()).then(resp => {\n    console.warn(resp);\n    console.warn('3 =========<');\n});\n \n返回结果：  返回值\n                \n           3   =========<\n因为then中cb()执行后返回的并不是一个函数，在Promise规范中会自动忽略调当前then，所以会把func中的返回值供下一个then使用，输出了“返回值”\n")])])]),t("p",[e._v("执行第四个方法：")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("func().then(cb).then(resp => {\n    console.warn(resp);\n    console.warn('4 =========<');\n});\n \n返回结果：  新的值\n                \n           4   =========<\n因为第一个方法在回调内部返回cb执行后的值，第四个方法则直接把cb当做回调，第一个方法与第四个方法异曲同工之妙，所以也输出了“新的值”。\n")])])]),t("p",[t("a",{attrs:{href:"https://promisesaplus.com/",target:"_blank",rel:"noopener noreferrer"}},[e._v("Promise规范（https://promisesaplus.com/）"),t("OutboundLink")],1)]),e._v(" "),t("p",[e._v("好啦，then说到这里说的已经够多了，现在我们来了解另一个朋友"),t("strong",[e._v("catch")]),e._v("吧")]),e._v(" "),t("p",[e._v("与Promise对象方法then方法并行的一个方法就是catch,与try  catch类似，catch就是用来捕获异常的，也就是和then方法中接受的第二参数rejected的回调是一样的，如下：")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("function promiseClick(){\n\t\tlet p = new Promise(function(resolve, reject){\n\t\t\tsetTimeout(function(){\n\t\t\t\tvar num = Math.ceil(Math.random()*20); //生成1-10的随机数\n\t\t\t\tconsole.log('随机数生成的值：',num)\n\t\t\t\tif(num<=10){\n\t\t\t\t\tresolve(num);\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\treject('数字大于10了即将执行失败回调');\n\t\t\t\t}\n\t\t\t}, 2000);\n\t\t   })\n\t\t   return p\n\t   }\n \n\tpromiseClick().then(\n\t\tfunction(data){\n\t\t\tconsole.log('resolved成功回调');\n\t\t\tconsole.log('成功回调接受的值：',data);\n\t\t}\n\t)\n\t.catch(function(reason){\n\t\tconsole.log('catch到rejected失败回调');\n\t\tconsole.log('失败回调的值：',reason);\n\t});\t\n")])])]),t("p",[e._v("输出结果：")]),e._v(" "),t("img",{attrs:{src:e.$withBase("/image/4.png"),alt:"直观的图"}}),e._v(" "),t("img",{attrs:{src:e.$withBase("/image/3.png"),alt:"直观的图"}}),e._v(" "),t("p",[e._v("resolve的东西，一定会进入then的第一个回调，肯定不会进入catch"),t("br"),e._v("\nreject后的东西，一定会进入then中的第二个回调，如果then中没有写第二个回调，则进入catch，\n"),t("strong",[e._v("另外，网络异常（比如断网），会直接进入catch而不会进入then的第二个回调")])]),e._v(" "),t("h3",{attrs:{id:"promise-all-批量执行"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#promise-all-批量执行"}},[e._v("#")]),e._v(" Promise.all() 批量执行")]),e._v(" "),t("p",[e._v("Promise.all可以将多个Promise实例包装成一个新的Promise实例。同时，成功和失败的返回值是不同的，成功的时候返回的是一个结果数组，而失败的时候则返回最先被reject失败状态的值。 Promse.all在处理多个异步处理时非常有用，比如说一个页面上需要等两个或多个ajax的数据回来以后才正常显示，在此之前只显示loading图标。")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("let wake = (time) => {\n  return new Promise((resolve, reject) => {\n    setTimeout(() => {\n      resolve(`${time / 1000}秒后醒来`)\n    }, time)\n  })\n}\n\nlet p1 = wake(3000)\nlet p2 = wake(2000)\n\nPromise.all([p1, p2]).then((result) => {\n  console.log(result)       // [ '3秒后醒来', '2秒后醒来' ]\n}).catch((error) => {\n  console.log(error)\n})\n\n")])])]),t("p",[t("strong",[e._v("需要特别注意的是，Promise.all获得的成功结果的数组里面的数据顺序和Promise.all接收到的数组顺序是一致的，即p1的结果在前，即便p1的结果获取的比p2要晚。这带来了一个绝大的好处：在前端开发请求数据的过程中，偶尔会遇到发送多个请求并根据请求顺序获取和使用数据的场景，使用Promise.all毫无疑问可以解决这个问题。")])]),e._v(" "),t("h3",{attrs:{id:"promise-race-的使用"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#promise-race-的使用"}},[e._v("#")]),e._v(" Promise.race()的使用")]),e._v(" "),t("p",[e._v("顾名思义，Promse.race就是赛跑的意思，意思就是说，Promise.race([p1, p2, p3])里面哪个结果获得的快，就返回那个结果，不管结果本身是成功状态还是失败状态。")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("let p1 = new Promise((resolve, reject) => {\n  setTimeout(() => {\n    resolve('success')\n  },1000)\n})\n\nlet p2 = new Promise((resolve, reject) => {\n  setTimeout(() => {\n    reject('failed')\n  }, 500)\n})\n\nPromise.race([p1, p2]).then((result) => {\n  console.log(result)\n}).catch((error) => {\n  console.log(error)  // 打开的是 'failed'\n})\n")])])]),t("p",[t("strong",[e._v("总而言之，言而总之，我觉得大多数人喜欢promise很大的原因呢就是因为他长的好看，又瘦又高，还有就因为他的家族庞大，有reject,resolve,all，then,catch...")])])])}),[],!1,null,null,null);n.default=s.exports}}]);